i2c:
  frequency: 50kHz
  sda: GPIO4
  scl: GPIO5

globals:
  - id: measure_delay
    type: int
    restore_value: yes
    initial_value: $measure_interval_dry

script:

  - id: begin_measure
    mode: single
    then:
      - switch.turn_on: resistance_bias
      - delay: $stabilization_delay

  - id: end_measure
    mode: single
    then:
      - switch.turn_off: resistance_bias

  - id: test_resistance
    mode: single
    then:
      - script.execute: begin_measure
      - script.wait: begin_measure

      - if:
          condition:
            lambda: "return id(resistance_sensor).state < $wet_resistance_when_booting;"
          then:
            - script.execute: its_raining

      - script.execute: end_measure
      - script.wait: end_measure

  - id: save_current_resistance
    then:
      - sensor.template.publish:
          id: latest_resistance_sensor
          state: !lambda "return id(resistance_sensor).state;"
      - sensor.template.publish:
          id: latest_average_resistance_sensor
          state: !lambda "return id(average_resistance_sensor).state;"

  # Currently:
  # * Rain is detected with the most recent value compared to a threshold
  # * To detect when it dries, we use the average

  # To be tested:
  # The lowest resistance that corresponds to a complete saturation
  # of the sensor is permanently recorded: If this value is not reached
  # but the resistance does not decrease during a period of time,
  # we know that it is not raining anymore.

  - id: update_average_values
    mode: single
    then:
      # Set the average resistance
      - if:
          condition:
            lambda: "return (id(resistance_sensor).state >= 0 && id(resistance_sensor).state <= $max_resistance);"
          then:
            - sensor.template.publish:
                id: average_resistance_sensor
                state: !lambda "return id(resistance_sensor).state;"

  - id: measure
    mode: single
    then:
      - script.execute: begin_measure
      - script.wait: begin_measure

      # Init latest resistance value if not a number
      - if:
          condition:
            lambda: "return isnan(id(latest_resistance_sensor).state);"
          then:
            - script.execute: save_current_resistance
            - script.wait: save_current_resistance
      - if:
          condition:
            lambda: "return isnan(id(latest_average_resistance_sensor).state);"
          then:
            - script.execute: save_current_resistance
            - script.wait: save_current_resistance

      # For debug purpose only
      - logger.log:
          level: INFO
          format: "> Resistance: %.1f vs latest resistance: %.1f"
          args: ['id(resistance_sensor).state', 'id(latest_resistance_sensor).state']

      - script.execute: update_average_values

      # Test for raining
      - if:
          condition:
            lambda: "return id(resistance_sensor).state + $rain_detection_threshold < id(latest_resistance_sensor).state;"
          then:
            - script.execute: its_raining

      # Test for drying
      - if:
          condition:
            lambda: "return id(average_resistance_sensor).state - $dry_detection_threshold > id(latest_average_resistance_sensor).state;"
          then:
            - script.execute: its_drying

      # Test for dry
      # We assume sensor is dry when current resistance == max resistance
      - if:
          condition:
            lambda: "return id(resistance_sensor).state == $max_resistance;"
          then:
            - script.execute: its_dry

      - script.execute: end_measure
      - script.wait: end_measure

  - id: measure_loop
    mode: single
    then:
      - while:
          condition:
            lambda: "return true;"
          then:
            - logger.log:
                format: "[Start measure]"
                level: INFO
            - script.execute: measure
            - script.wait: measure
            - delay: !lambda "return id(measure_delay);"

  - id: its_raining
    mode: single
    then:
      - logger.log: "It's raining !"
      - script.execute: save_current_resistance
      - script.wait: save_current_resistance
      - homeassistant.event:
          event: esphome.its_raining
      - text_sensor.template.publish:
          id: text_status
          state: "Raining"
      - binary_sensor.template.publish:
          id: raining
          state: on
      - binary_sensor.template.publish:
          id: drying
          state: off
      - globals.set:
          id: measure_delay
          value: $measure_interval_wet

  - id: its_drying
    mode: single
    then:
      - logger.log: "It's drying !"
      - script.execute: save_current_resistance
      - script.wait: save_current_resistance
      - text_sensor.template.publish:
          id: text_status
          state: "Drying"
      - binary_sensor.template.publish:
          id: raining
          state: off
      - binary_sensor.template.publish:
          id: drying
          state: on
      - globals.set:
          id: measure_delay
          value: $measure_interval_wet

  - id: its_dry
    mode: single
    then:
      - logger.log: "It's dry !"
      - script.execute: save_current_resistance
      - script.wait: save_current_resistance
      - text_sensor.template.publish:
          id: text_status
          state: "Dry"
      - binary_sensor.template.publish:
          id: raining
          state: off
      - binary_sensor.template.publish:
          id: drying
          state: off
      - globals.set:
          id: measure_delay
          value: $measure_interval_dry

